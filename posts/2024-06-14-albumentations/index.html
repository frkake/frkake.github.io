<!doctype html><html lang=ja dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Albumentationsにおける自作変換クラス作成 | Less is more</title><meta name=keywords content="Python,Albumentations,Data Augmentation"><meta name=description content="Project Paper Code Other なんだかものすごく久しぶりの投稿ですが、今回はAlbumentationsにおける自作変換クラス作成について書いていきます。 画像変換"><meta name=author content><link rel=canonical href=https://frkake.com/posts/2024-06-14-albumentations/><link crossorigin=anonymous href=/assets/css/stylesheet.fc220c15db4aef0318bbf30adc45d33d4d7c88deff3238b23eb255afdc472ca6.css integrity="sha256-/CIMFdtK7wMYu/MK3EXTPU18iN7/MjiyPrJVr9xHLKY=" rel="preload stylesheet" as=style><link rel=icon href=https://frkake.com/images/steamed_rice_brown.svg><link rel=icon type=image/png sizes=16x16 href=https://frkake.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://frkake.com/favicon-32x32.png><link rel=apple-touch-icon href=https://frkake.com/apple-touch-icon.png><link rel=mask-icon href=https://frkake.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=ja href=https://frkake.com/posts/2024-06-14-albumentations/><link rel=stylesheet href=/css/common/header.css><link rel=stylesheet href=/css/biography.css><link rel=stylesheet href=/css/caption.css><link rel=stylesheet href=/css/cite.css><link rel=stylesheet href=/css/links.css><link rel=stylesheet href=/css/collapse.css><link rel=stylesheet href=/css/notice.css><link rel=stylesheet href=/css/theme-vars.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/1.1.0/magnific-popup.min.css><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/1.1.0/jquery.magnific-popup.min.js></script>
<script src=/js/profile-image-protect.js></script><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><style>.katex-display{overflow-x:auto;display:inline-block;max-width:100%}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css integrity=sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js integrity=sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:title" content="Albumentationsにおける自作変換クラス作成"><meta property="og:description" content="Project Paper Code Other なんだかものすごく久しぶりの投稿ですが、今回はAlbumentationsにおける自作変換クラス作成について書いていきます。 画像変換"><meta property="og:type" content="article"><meta property="og:url" content="https://frkake.com/posts/2024-06-14-albumentations/"><meta property="og:image" content="https://frkake.com/data/thumbnail.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-13T23:06:34+00:00"><meta property="article:modified_time" content="2024-06-13T23:06:34+00:00"><meta property="og:site_name" content="Less is more"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://frkake.com/data/thumbnail.png"><meta name=twitter:title content="Albumentationsにおける自作変換クラス作成"><meta name=twitter:description content="Project Paper Code Other なんだかものすごく久しぶりの投稿ですが、今回はAlbumentationsにおける自作変換クラス作成について書いていきます。 画像変換"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://frkake.com/posts/"},{"@type":"ListItem","position":2,"name":"Albumentationsにおける自作変換クラス作成","item":"https://frkake.com/posts/2024-06-14-albumentations/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Albumentationsにおける自作変換クラス作成","name":"Albumentationsにおける自作変換クラス作成","description":"Project Paper Code Other なんだかものすごく久しぶりの投稿ですが、今回はAlbumentationsにおける自作変換クラス作成について書いていきます。 画像変換","keywords":["Python","Albumentations","Data Augmentation"],"articleBody":" Project\nPaper\nCode\nOther\nなんだかものすごく久しぶりの投稿ですが、今回はAlbumentationsにおける自作変換クラス作成について書いていきます。\n画像変換するとき、Albumentationsって便利ですよね。なんといっても変換できる種類の数が豊富なのが嬉しいです。\nただ、自分で新たに変換クラスを作成しようとすると、ドキュメントが豊富とは言えないと思うので、誰かの役に立てばと思い、今回の記事を書くことにしました（未来の自分のためかもしれない）。\n実行例はすべてこのリポジトリにあります。\n基本的な使い方 マスク画像を使って画像をクロップする Albumentationsの基本的な使い方を確認するために、以下のコードを実行してみます。画像とマスクの大きさが中途半端で申し訳ないです。\nimage = cv2.imread('data/images/dog_and_cat.png') # image.shape: (340, 500, 3) mask = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) # mask.shape: (340, 500) transform = A.Compose([ A.CropNonEmptyMaskIfExists(height=200, width=200, p=1), A.PadIfNeeded(min_height=210, min_width=210, border_mode=cv2.BORDER_CONSTANT, value=(128, 128, 128), mask_value=128, p=1), ]) transformed = transform(image=image, mask=mask_dog) grid_image = make_grid_image(transformed.values(), n_cols=2) # 結果の画像をタイル状に並べる cv2.imwrite('data/results/crop_dog_by_mask.png', grid_image) make_grid_image() make_grid_image関数は、複数の画像をタイル状に並べる関数です。\ndef make_grid_image( images: Sequence[np.ndarray], n_cols: int, ): images = [ cv2.cvtColor(image, cv2.COLOR_GRAY2RGB) if image.ndim == 2 else image for image in images] n_rows = len(images) // n_cols h, w, c = images[0].shape grid_image = np.zeros((h * n_rows, w * n_cols, c), dtype=np.uint8) for i, image in enumerate(images): row = i // n_cols col = i % n_cols grid_image[row * h:(row + 1) * h, col * w:(col + 1) * w] = image return grid_image images/dog_and_cat.png masks/dog.png data/results/crop_dog_by_mask.png ここでは、画像(=image)に犬と猫が写った写真。マスク(=mask)には犬の領域に対応したマスク画像を与えています。 データ変換のパイプラインとしては次の処理を行っています。\nA.CropNonEmptyMaskIfExistsでマスクを含むような形で画像を200x200にクロップ A.Resizeで256x256にリサイズ A.PadIfNeededで外周4ピクセル分をを128でパディング ご覧の通り、犬の領域に合わせて画像がクロップされていることがわかります。\nimageとmaskが同様に変換されていることが確認できます。\n解像度の関係でわかりにくいかもしれませんが、imageとmaskによってResizeによる補間処理は異なっています。imageの方は、引数通り線形補間が行われますが、maskの方は最近傍補間が行われています。\nA.Composeに一連の変換処理をリストで渡すことで、変換処理をパイプラインとして実行できます。\n基本的にAlbumentationsの変換処理のフォーマットはNumpy形式と決まっており、A.Composeは、まず初めに入力がそれらの形式になっているのかのチェックやimageとmaskが同じshapeなのかなどのチェックを行います。その後、変換処理を実行していきます。\n今回の記事ではRGB画像とマスク画像しか扱いませんが、他にもBBoxやキーポイントなどもいい感じに変換できます。\nマスクが複数になったら マスクが複数になったら、maskの代わりに各マスクをリストにしたmasksを引数として渡してあげると複数のマスクに同様の変換を適用してくれます。\nimage = cv2.imread('data/images/dog_and_cat.png') # image.shape: (340, 500, 3) mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) # mask_dog.shape: (340, 500) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) # mask_cat.shape: (340, 500) transformed = transform(image=image, masks=[mask_dog, mask_cat]) grid_image = make_grid_image([transformed[\"image\"], ] + transformed['masks'], n_cols=3) cv2.imwrite('data/results/crop_dog_and_cat_by_masks.png', grid_image) images/dog_and_cat.png masks/dog.png masks/cat.png data/results/crop_dog_and_cat_by_masks.png A.CropNonEmptyMaskIfExistsは、複数のマスクがあると、それらのマスク領域の和集合を含むようにしてクロップします。この場合、犬か猫の領域のどちらかを少なくとも含むように、領域をクロップします。\nAlbumentationsの各変換モジュールがどのターゲット（mask, bbox, keypoint, global_label）に対して作用するのかは、リファレンスを見るとわかりやすいです。\nPixel-levelの変換は、輝度調整や色調変換、ボケやノイズなどの効果をつけたりするものが多く、画像にのみ作用します。\nSpatial-levelの変換は、クロップやリサイズ、パディングや回転などの幾何変換を伴うものが多く、画像以外にもマスクやBBox、キーポイントなどにも作用します。各クラスによって作用するターゲットが異なるので、リファレンスの表を見て確認する必要があります。\n自作クラスの作成 さて、ここからが本題です。自作の変換クラスを作成してみます。まずは基本的な自作クラスの作成方法を解説します。\n基本編 Albumentationsでは、主に次の3つのクラスをベースクラスとして自作クラスを作成します。\nA.BasicTransform\nA.ImageOnlyTransformとA.DualTransformの基底クラス。\n色々な変換をするときのパラメータを設定するメソッドを持っています。 A.ImageOnlyTransform\n画像のみを変換するときに使う基底クラス。 A.DualTransform\n画像とマスクやBBox、キーポイントを同時に変換するときに使う基底クラス 特殊な変換クラスでもない限り、基本的にはA.ImageOnlyTransformかA.DualTransformを継承して作成していくのが一般的だと思います。\nImageOnlyTransformを継承したクラス A.ImageOnlyTransformを継承して、画像の特定のチャネルだけ残して他を0にする自作変換クラスSelectChannelを作成してみます。\nclass SelectChannel(A.ImageOnlyTransform): def __init__(self, channel: int, always_apply=False, p=1): super(SelectChannel, self).__init__(always_apply, p) self.channel = channel def apply(self, image: np.ndarray, **params) -\u003e np.ndarray: H, W, C = image.shape canvas = np.zeros_like(image) canvas[..., self.channel] = image[..., self.channel] return canvas def get_transform_init_args_names(self): return (\"channel\",) 実行例 青だけ残す処理を行ってみます。OpenCVで読み込んでおり、BGRなので0チャネル目が青です。\ntransform = A.Compose([ SelectChannel(channel=0, p=1), ]) image = cv2.imread('data/images/dog_and_cat.png') transformed = transform(image=image) cv2.imwrite('data/results/select_b.png', transformed[\"image\"]) images/dog_and_cat.png results/select_b.png このように画像への処理内容はapply()に記述します。\nget_transform_init_args_names()というメソッドは、A.ReplayComposeを使うときに必要になるメソッドです。まだ必要ないのですが、後でA.ReplayComposeの説明もしたいので、まとめて定義しておきます。\napply()には、transform(image=image)で渡されたimageが渡されます。それに対して処理を行って返却すると、返り値の辞書のimageキーに値が格納されます。\nDualTransformを継承したクラス さて、次は指定した領域をクロップするクラス Cropを作成してみます。A.Cropの簡略版です。\nclass Crop(A.DualTransform): def __init__( self, x_min: int, y_min: int, x_max: int, y_max: int, always_apply=False, p=1, ): super(Crop, self).__init__(always_apply, p) self.x_min = x_min self.y_min = y_min self.x_max = x_max self.y_max = y_max def apply(self, image, **params): return image[self.y_min:self.y_max, self.x_min:self.x_max] def apply_to_mask(self, mask: np.ndarray, **params) -\u003e np.ndarray: return mask[self.y_min:self.y_max, self.x_min:self.x_max] def apply_to_masks(self, masks: List[np.ndarray], **params) -\u003e List[np.ndarray]: return [mask[self.y_min:self.y_max, self.x_min:self.x_max] for mask in masks] def get_transform_init_args_names(self): return (\"x_min\", \"y_min\", \"x_max\", \"y_max\") 実行例 transform = A.Compose([ Crop(x_min=100, y_min=100, x_max=300, y_max=300, p=1), A.PadIfNeeded(min_height=210, min_width=210, border_mode=cv2.BORDER_CONSTANT, value=(128, 128, 128), mask_value=128, p=1), ]) image = cv2.imread('data/images/dog_and_cat.png') mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) transformed = transform(image=image, masks=[mask_dog, mask_cat]) grid_image = make_grid_image([transformed[\"image\"],] + transformed['masks'], n_cols=3) cv2.imwrite('data/results/crop_constant.png', grid_image) images/dog_and_cat.png results/crop_constant.png Cropクラスで指定した領域がクロップされていることが確認できます。\nこのクラスは、画像とマスクを同時にクロップする処理を行います。apply()メソッドは画像に対する処理、apply_to_mask()メソッドはマスクに対する処理、apply_to_masks()メソッドは複数のマスクに対する処理を行います。\nA.DualTransformでは、他にも apply_to_bbox()、apply_to_keypoint()、apply_to_global_label() などがあり、それぞれのターゲットに対してメソッドを定義することができます。\nNote 実は、上の変換クラスCropはさらに単純化することができます。apply_to_mask()とapply_to_masksを定義していますが、次のようにapply()メソッドを定義するだけで、maskも同様にクロップされます。imageとmaskは対応したものとして扱われ、同じ変換処理が適用されます。\nそのため、次のCropクラスは上のCropクラスと同じ挙動をします。\nclass Crop(A.DualTransform): def __init__(self, x_min, y_min, x_max, y_max, always_apply=False, p=1): super(Crop, self).__init__(always_apply, p) self.x_min = x_min self.y_min = y_min self.x_max = x_max self.y_max = y_max def apply(self, image, **params): return image[self.y_min:self.y_max, self.x_min:self.x_max] def get_transform_init_args_names(self): return (\"x_min\", \"y_min\", \"x_max\", \"y_max\") 唯一違うのはリサイズなどで補間処理を見つけたら、mask（およびmasks）の場合は最近傍補間が適用されるように自動的に修正されるという点です。\nimageとは異なる処理をしたい場合や可読性を上げたい場合を除けば、apply() メソッドのみを定義しておけば十分です。\n応用編 応用編では、より複雑な変換クラスを作成してみます。\nランダム値を扱いたい 適用するごとにランダム値を生成する まずは、ランダムなシフトを行う変換クラスRandomShiftを作成してみます。\nclass RandomShift(A.DualTransform): def __init__( self, x_shift: Tuple[int, int], y_shift: Tuple[int, int], always_apply=False, p=1, ): super().__init__(always_apply, p) self.x_shift = x_shift self.y_shift = y_shift def apply( self, image: np.ndarray, x_shift: int, y_shift: int, **params: Any, ) -\u003e np.ndarray: H, W, *_ = image.shape canvas = np.zeros_like(image) x_min = max(0, x_shift) y_min = max(0, y_shift) x_max = min(W, W + x_shift) y_max = min(H, H + y_shift) canvas[y_min:y_max, x_min:x_max] = image[max(0, -y_shift):min(H, H - y_shift), max(0, -x_shift):min(W, W - x_shift)] return canvas def get_transform_init_args_names(self): return (\"x_shift\", \"y_shift\") def get_params(self): return { \"x_shift\": np.random.randint(*self.x_shift), \"y_shift\": np.random.randint(*self.y_shift), } 実行例 上下左右に[-100, 100]ピクセルの範囲でランダムにシフトする処理を行ってみます。\ntransform = RandomShift(x_shift=(-100, 100), y_shift=(-100, 100), p=1) for i in range(2): image = cv2.imread('data/images/dog_and_cat.png') mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) transformed = transform(image=image, masks=[mask_dog, mask_cat]) grid_image = make_grid_image([transformed[\"image\"],] + transformed['masks'], n_cols=3) cv2.imwrite(f'data/results/shift_{i:02d}.png', grid_image) data/results/shift_00.png data/results/shift_01.png ランダムになっていることを確認するために2回実行してみました。2回とも異なるシフトが適用されていることがわかります。さらに、画像とマスクの両方で同じシフトが適用されていることも確認できます。\nget_params()で、適用するごとにランダムな値を生成しています。\nget_params()の返り値は、apply()メソッドの引数に渡されます。今回はapply()の引数にx_shiftとy_shiftを追加して直接受けてみましたが、特に指定しないと**paramsで受け取ることができます。\nコラムでも述べたように、apply()メソッドは他のターゲットにも適用されるので、apply_to_mask()やapply_to_bbox()などでも共有して使うことができます。これにより、画像とマスクが同じシフトを受けることが保証されます。\n入力データに依存したランダム値を生成する 次に、ランダムにクロップする変換クラスRandomCropを作成してみます。RandomCropは、ランダムにクロップする位置を変更しますが、クロップする矩形が画像の範囲を超えないようにするため、画像のサイズに依存したランダム値を生成する必要があります。\nclass RandomCrop(A.DualTransform): def __init__( self, height: int, width: int, always_apply=False, p=1, ): super().__init__(always_apply, p) self.height = height self.width = width def apply( self, image: np.ndarray, x_min: int, y_min: int, x_max: int, y_max: int, **params, ) -\u003e np.ndarray: return image[y_min:y_max, x_min:x_max] def get_transform_init_args_names(self): return (\"height\", \"width\") def get_params_dependent_on_targets(self, params): image = params[\"image\"] H, W, C = image.shape x_min = np.random.randint(0, W - self.width) y_min = np.random.randint(0, H - self.height) x_max = x_min + self.width y_max = y_min + self.height return { \"x_min\": x_min, \"y_min\": y_min, \"x_max\": x_max, \"y_max\": y_max, } @property def targets_as_params(self): return [\"image\"] 実行例 画像から200x200サイズの領域をランダムにクロップしてみます。今回もランダムになっているか確認するために2回実行してみます。\ntransform = A.Compose([ RandomCrop(height=200, width=200, p=1), A.PadIfNeeded(min_height=210, min_width=210, border_mode=cv2.BORDER_CONSTANT, value=(128, 128, 128), mask_value=128, p=1), ]) for i in range(2): image = cv2.imread('data/images/dog_and_cat.png') mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) transformed = transform(image=image, masks=[mask_dog, mask_cat]) grid_image = make_grid_image([transformed[\"image\"],] + transformed['masks'], n_cols=3) cv2.imwrite(f'data/results/randomcrop_{i:02d}.png', grid_image) data/results/randomcrop_00.png data/results/randomcrop_01.png 画像内のランダムな位置がクロップされていることが確認できます。クロップ領域が画像の範囲を超えないようになっていることも確認できます。\nget_params_dependent_on_targets()で、paramsに含まれるimageからランダムな値を生成しています。get_params_dependent_on_targets()で利用したいターゲットは、targets_as_paramsプロパティで指定しておかなければなりません。target_as_paramsでparamsのパラメータを収集（辞書を構築）して、get_params_dependent_on_targets()を実行する流れになっています。 get_params()とget_params_dependent_on_targets()を別々に紹介しましたが、get_params_dependent_on_targets()はget_params()の代わりに使うこともできます。両方定義した場合は、互いの返り値の辞書がマージされます。\n他のデータ形式も変換したい Albumentationsの標準では、画像とマスク、BBox、キーポイント、グローバルラベルへの処理をサポートしています。\nしかし、中には文字列やリストなどの他のデータ形式を変換したい場合もあるでしょう。ここでは、入力画像ファイル名の末尾（suffix）に変換した処理名を追加する処理を加えてみましょう。\nclass CropAndAddSuffix(Crop): def apply_to_str(self, string: str, **params) -\u003e str: return string + \"/cropped\" @property def targets(self) -\u003e List[str]: return { \"image\": self.apply, \"mask\": self.apply, \"image_name\": self.apply_to_str, } 実行例 CropAndAddSuffixを実行しています。\ntransform = CropAndAddSuffix(100, 100, 300, 300, p=1) image_path = Path('data/images/dog_and_cat.png') image = cv2.imread(str(image_path)) transformed = transform(image=image, image_name=image_path.stem) print(f\"transformed.keys(): {transformed.keys()}\") # ==\u003e transformed.keys(): dict_keys(['image', 'masks', 'image_name']) print(f\"transformed['image_name']: {transformed['image_name']}\") # ==\u003e transformed['image_name']: dog_and_cat/cropped 実行結果を見てみると、image_nameキーに渡したファイル名がdog_and_cat/croppedに変換されていることがわかります。\n前節で作成したCropクラスにapply_to_str()とtargetsプロパティを追加しています。このように targetsプロパティで渡したキーに対して、処理させたいメソッドを指定することで、他のデータ形式にも変換処理を適用できます。\nこうすると、変換時にimage_nameというキーで渡した文字列に対して、apply_to_str()が適用され、/croppedというsuffixを追加します。\nあまりやらないですが、どういう処理をした画像なのかをファイル名に残しておきたい場合などに使えるかもしれません。\n他の入力情報を利用した変換をしたい マスクが複数になったらで紹介したように、複数のマスクがある場合には次のようにmasksにマスクのリストを渡すことで、それぞれのマスクに同じ変換を適用できます。\ntransformed = transform(image=image, masks=[mask_dog, mask_cat]) 例えば、犬と猫のマスクを両方渡して、犬の方のマスク領域だけを抽出する変換クラスExtractDogAreaを素朴に作成すると次のようになります。\nclass CropDogArea(A.DualTransform): def __init__(self, always_apply=False, p=1): super().__init__(always_apply, p) def apply( self, image: np.ndarray, x_min: int, y_min: int, x_max: int, y_max: int, **params, ) -\u003e np.ndarray: return image[y_min:y_max, x_min:x_max] def get_params_dependent_on_targets(self, params): mask = params[\"masks\"][0] # HERE! indices = np.where(mask \u003e 0) y_min, y_max = indices[0].min(), indices[0].max() x_min, x_max = indices[1].min(), indices[1].max() return { \"x_min\": x_min, \"y_min\": y_min, \"x_max\": x_max, \"y_max\": y_max, } @property def targets_as_params(self): return [\"masks\"] 実行例 transform = A.Compose([ CropDogArea(p=1), A.PadIfNeeded( min_height=200, min_width=130, value=(128, 128, 128), mask_value=128, )], ) image = cv2.imread('data/images/dog_and_cat.png') mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) transformed = transform(image=image, masks=[mask_dog, mask_cat]) grid_image = make_grid_image([transformed[\"image\"],] + transformed['masks'], n_cols=3) cv2.imwrite('data/results/crop_dog_area.png', grid_image) 左から画像、犬のマスク画像、猫のマスク画像に対応しており、それぞれの犬のマスク領域に対応した領域がクロップされていることがわかります。\ndata/results/crop_dog_area.png しかし、これでは入力したマスクの順序を覚えておかなければならないという問題があります。様々な変換を組み合わせて適用する場合に、それらすべてのクラスで0番目のマスクが犬のマスクであることを共通化するのは難しいですし、利用する際に順序を間違えてしまう可能性もあります。get_params_dependent_on_targets()の中が見苦しいことになっています。\nですので、mask_dogとmask_catをmasksにまとめて渡すのではなく、mask_dogとmask_catをそれぞれdog_maskとcat_maskとして渡せるようにしてみましょう。\nclass CropDogArea(A.DualTransform): def __init__(self, always_apply=False, p=1): super().__init__(always_apply, p) def apply( self, image: np.ndarray, x_min: int, y_min: int, x_max: int, y_max: int, **params, ) -\u003e np.ndarray: return image[y_min:y_max, x_min:x_max] def get_params_dependent_on_targets(self, params): mask = params[\"mask_dog\"] indices = np.where(mask \u003e 0) y_min, y_max = indices[0].min(), indices[0].max() x_min, x_max = indices[1].min(), indices[1].max() return { \"x_min\": x_min, \"y_min\": y_min, \"x_max\": x_max, \"y_max\": y_max, } @property def targets_as_params(self): return [\"mask_dog\"] get_params_dependent_on_targets()やtargets_as_paramsがmask_dogをそのまま利用できるようになりました。\nしかし、なにも考えずに利用すると、mask_dogとmask_catはマスクとして扱われないため、クロップされません。なので、実行時に「mask_dogとmask_catはマスク処理をする対象のデータである」ことを明示的に指定する必要があります。\nA.Composeのadditional_targets引数を使って、キーにターゲット名、値にターゲットの種類を指定します。\ntransform = A.Compose([ CropDogArea(p=1), A.PadIfNeeded( min_height=210, min_width=140, value=(128, 128, 128), mask_value=128, )], additional_targets={\"mask_dog\": \"mask\", \"mask_cat\": \"mask\"} ) 実行例 mask_dog, mask_catをそれぞれ処理した結果は同じキーに格納されて返ってきます。\nimage = cv2.imread('data/images/dog_and_cat.png') mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) transformed = transform(image=image, mask_dog=mask_dog, mask_cat=mask_cat) grid_image = make_grid_image([ transformed[\"image\"], transformed[\"mask_dog\"], transformed[\"mask_cat\"]], n_cols=3) cv2.imwrite('data/results/crop_dog_area.png', grid_image) 処理結果の画像は上の結果と同じですが再掲します。\n左から画像、犬のマスク画像、猫のマスク画像に対応しており、それぞれの犬のマスク領域に対応した領域がクロップされていることがわかります。\ndata/results/crop_dog_area.png additional_targets –\u003e targetsのように辞書をたどって行くことで、処理対象のメソッドへとたどり着きます。\nA.DualTransformには次のtargetsが定義されているので、\"mask_dog\" –\u003e \"mask\" –\u003e apply_to_mask() にたどり着きます。\n@property def targets(self) -\u003e Dict[str, Callable[..., Any]]: return { \"image\": self.apply, \"mask\": self.apply_to_mask, \"masks\": self.apply_to_masks, \"bboxes\": self.apply_to_bboxes, \"keypoints\": self.apply_to_keypoints, } 複数種類の入力データを組み合わせた処理をしたい \u0026\u0026 返り値を追加したい これまでの変換処理は、それぞれの画像やマスクに対して処理を行い、その結果をimageやmasksとして返していました。しかし、処理結果に追加の情報を返したい場合や、複数種類の入力データを組み合わせた処理を行いたい場合もあるでしょう。\nこの節では、複数の別々に用意したカテゴリマスクを一枚の画像にまとめる処理を行う変換クラスMergeMasksを作成してみます。\n具体的には、犬、猫、芝生、木の4つのマスクを別々に用意したので、それらを一枚の画像にまとめてセグメンテーション用のマスクを作成します。ただし、犬、猫はオブジェクトクラス、芝生、木は背景クラスとしてラベルをまとめます。\nclass MergeMasks(A.DualTransform): def __init__( self, object_value: Tuple[int, int, int] = (255, 0, 0), bg_value: Tuple[int, int, int] = (0, 255, 0), always_apply=False, p=1, ): super().__init__(always_apply, p) self.object_value = object_value self.bg_value = bg_value def apply(self, img: np.ndarray, **params) -\u003e np.ndarray: return img def apply_with_params( self, params: Dict[str, Any], *args: Any, **kwargs: Any, ) -\u003e Dict[str, Any]: res = super().apply_with_params(params, *args, **kwargs) H, W = res[\"mask_dog\"].shape canvas = np.zeros((H, W, 3), dtype=np.uint8) mask_object = np.logical_or(res[\"mask_dog\"], res[\"mask_cat\"]) mask_bg = np.logical_or(res[\"mask_grass\"], res[\"mask_tree\"]) canvas[mask_object] = self.object_value canvas[mask_bg] = self.bg_value res[\"mask_merged\"] = canvas res[\"image_overlay\"] = cv2.addWeighted(res[\"image\"], 0.5, canvas, 0.5, 0) return res def get_transform_init_args_names(self) -\u003e Tuple[str]: return (\"object_value\", \"bg_value\") 実行例 画像と各マスクを[-10, 10]度の範囲でランダムに回転させ、MergeMasksでマスクをマージしてみます。\n処理の対象がわかりやすいように、少しコードが長くなってしまいますが、犬、猫、芝生、木のマスクを読み込んでtransformに渡しています。\n返り値には、マージ後のマスクmask_mergedと、画像とマスクを重ねた画像image_overlayが追加されているので、それらを描画してみました。\ntransform = A.Compose([ A.Rotate(limit=10, border_mode=0, p=1), MergeMasks(object_value=(0, 170, 246), bg_value=(255, 90, 0), p=1), ], additional_targets={ \"mask_dog\": \"mask\", \"mask_cat\": \"mask\", \"mask_grass\": \"mask\", \"mask_tree\": \"mask\", }) image = cv2.imread('data/images/dog_and_cat.png') mask_dog = cv2.imread('data/masks/dog.png', cv2.IMREAD_GRAYSCALE) mask_cat = cv2.imread('data/masks/cat.png', cv2.IMREAD_GRAYSCALE) mask_grass = cv2.imread('data/masks/grass.png', cv2.IMREAD_GRAYSCALE) mask_tree = cv2.imread('data/masks/tree.png', cv2.IMREAD_GRAYSCALE) transformed = transform( image=image, mask_dog=mask_dog, mask_cat=mask_cat, mask_grass=mask_grass, mask_tree=mask_tree, ) grid_image = make_grid_image([ transformed[\"image\"], transformed[\"mask_merged\"], transformed[\"image_overlay\"]], n_cols=3) cv2.imwrite('data/results/merged_mask.png', grid_image) data/results/merged_mask.png 複数のマスクを組み合わせたり、追加の情報を返す場合は、apply_with_params()メソッドを使うと実現できます。\n本来のapply_with_params()は、各ターゲットに対して適用するメソッドの選択やちょっとしたパラメータの更新を行い、実際に各処理（apply()やapply_to_mask()など）を実行するメソッドです。 言い換えると、各入力情報を保持しており、apply_with_params()の返り値がtransformしたときの返り値となります。ですので、ここでは返り値の辞書に新たな要素を追加しています。 引数であるparamsには、get_params()とget_params_dependent_on_targets()から受け取った値が入っており、args, kwargsには、各入力データが入っています。\nベースクラスのリファレンス メソッド or プロパティ 説明 apply() 画像に対する変換処理を行うメソッド。 A.DualTransform の場合は、マスクに対する処理も行う。 targets_as_params get_params_dependent_on_targets()で利用するターゲットを指定 add_targets() 辞書形式で追加で処理したいターゲット名とその対象として扱わせたいターゲット名を指定します。上の例で出していたA.Composeのadditional_targetsと同じです。A.Composeでadditional_targetsを指定すると、内部的には各変換クラスのadd_targets()が呼ばれています。 apply_with_params() targetsで指定した辞書に従って、各ターゲットに対する処理を行う。処理を行う前にupdate_params()によるパラメータ更新も行う。 get_params() 入力データに依存しないパラメータを準備する関数。変換ごとに一度しか呼ばれないので、同時に入力したデータでランダム値を共有したい場合に便利。 get_params_dependent_on_targets() 入力データに依存したパラメータを準備する関数。get_params()の上位互換という印象。 get_transform_init_args_names() そのクラスを初期化するのに必要なパラメータ名のリストを返す。通常は不要だが、A.ReplanComposeなどで同じパラメータを使いまわす場合に使う。 set_deterministic() targets 変換対象のターゲット名とそれを処理するメソッドを指定する。 update_params() apply_with_params()内部で最初に呼ばれる。 paramsとkwargsの両方が渡されるので、get_params(), get_params_dependent_on_targets()の中で一番使える情報が多い。 変換に利用されるパラメータparamsは、次の3つのメソッドを順番に呼び出し、辞書を更新していきます。\nget_params() get_params_dependent_on_targets() update_params() ","wordCount":"8287","inLanguage":"ja","image":"https://frkake.com/data/thumbnail.png","datePublished":"2024-06-13T23:06:34Z","dateModified":"2024-06-13T23:06:34Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://frkake.com/posts/2024-06-14-albumentations/"},"publisher":{"@type":"Organization","name":"Less is more","logo":{"@type":"ImageObject","url":"https://frkake.com/images/steamed_rice_brown.svg"}}}</script></head><body id=top><link rel=stylesheet href=/css/pubdate.css><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://frkake.com/ accesskey=h title="Less is more (Alt + H)"><img src=https://frkake.com/images/steamed_rice_brown.svg alt aria-label=logo height=30>Less is more</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://frkake.com/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://frkake.com/aboutme title=プロフィール><span>プロフィール</span></a></li><li><a href=https://frkake.com/posts title=記事><span>記事</span></a></li><li><a href=https://frkake.com/tags title=タグ><span>タグ</span></a></li><li><a href=https://frkake.com/pubdate title=ソート><span>ソート</span></a></li><li><a href=https://frkake.com/search title=検索><span>検索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Albumentationsにおける自作変換クラス作成</h1><div class=post-meta><span title='2024-06-13 23:06:34 +0000 UTC'>2024-06-13</span></div></header><figure class=entry-cover><img loading=eager srcset="https://frkake.com/posts/2024-06-14-albumentations/data/thumbnail_hu6746fee3650c9d9bebfa5aa501e0980b_17339_360x0_resize_box_3.png 360w ,https://frkake.com/posts/2024-06-14-albumentations/data/thumbnail_hu6746fee3650c9d9bebfa5aa501e0980b_17339_480x0_resize_box_3.png 480w ,https://frkake.com/posts/2024-06-14-albumentations/data/thumbnail.png 554w" sizes="(min-width: 768px) 720px, 100vw" src=https://frkake.com/posts/2024-06-14-albumentations/data/thumbnail.png alt width=554 height=134></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目次</span></summary><div class=inner><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%9a%84%e3%81%aa%e4%bd%bf%e3%81%84%e6%96%b9 aria-label=基本的な使い方>基本的な使い方</a><ul><li><a href=#%e3%83%9e%e3%82%b9%e3%82%af%e7%94%bb%e5%83%8f%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e7%94%bb%e5%83%8f%e3%82%92%e3%82%af%e3%83%ad%e3%83%83%e3%83%97%e3%81%99%e3%82%8b aria-label=マスク画像を使って画像をクロップする>マスク画像を使って画像をクロップする</a></li><li><a href=#%e3%83%9e%e3%82%b9%e3%82%af%e3%81%8c%e8%a4%87%e6%95%b0%e3%81%ab%e3%81%aa%e3%81%a3%e3%81%9f%e3%82%89 aria-label=マスクが複数になったら>マスクが複数になったら</a></li></ul></li><li><a href=#%e8%87%aa%e4%bd%9c%e3%82%af%e3%83%a9%e3%82%b9%e3%81%ae%e4%bd%9c%e6%88%90 aria-label=自作クラスの作成>自作クラスの作成</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%b7%a8 aria-label=基本編>基本編</a><ul><li><a href=#imageonlytransform%e3%82%92%e7%b6%99%e6%89%bf%e3%81%97%e3%81%9f%e3%82%af%e3%83%a9%e3%82%b9 aria-label=ImageOnlyTransformを継承したクラス>ImageOnlyTransformを継承したクラス</a></li><li><a href=#dualtransform%e3%82%92%e7%b6%99%e6%89%bf%e3%81%97%e3%81%9f%e3%82%af%e3%83%a9%e3%82%b9 aria-label=DualTransformを継承したクラス>DualTransformを継承したクラス</a></li></ul></li><li><a href=#%e5%bf%9c%e7%94%a8%e7%b7%a8 aria-label=応用編>応用編</a><ul><li><a href=#%e3%83%a9%e3%83%b3%e3%83%80%e3%83%a0%e5%80%a4%e3%82%92%e6%89%b1%e3%81%84%e3%81%9f%e3%81%84 aria-label=ランダム値を扱いたい>ランダム値を扱いたい</a><ul><li><a href=#%e9%81%a9%e7%94%a8%e3%81%99%e3%82%8b%e3%81%94%e3%81%a8%e3%81%ab%e3%83%a9%e3%83%b3%e3%83%80%e3%83%a0%e5%80%a4%e3%82%92%e7%94%9f%e6%88%90%e3%81%99%e3%82%8b aria-label=適用するごとにランダム値を生成する>適用するごとにランダム値を生成する</a></li><li><a href=#%e5%85%a5%e5%8a%9b%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ab%e4%be%9d%e5%ad%98%e3%81%97%e3%81%9f%e3%83%a9%e3%83%b3%e3%83%80%e3%83%a0%e5%80%a4%e3%82%92%e7%94%9f%e6%88%90%e3%81%99%e3%82%8b aria-label=入力データに依存したランダム値を生成する>入力データに依存したランダム値を生成する</a></li></ul></li><li><a href=#%e4%bb%96%e3%81%ae%e3%83%87%e3%83%bc%e3%82%bf%e5%bd%a2%e5%bc%8f%e3%82%82%e5%a4%89%e6%8f%9b%e3%81%97%e3%81%9f%e3%81%84 aria-label=他のデータ形式も変換したい>他のデータ形式も変換したい</a></li><li><a href=#%e4%bb%96%e3%81%ae%e5%85%a5%e5%8a%9b%e6%83%85%e5%a0%b1%e3%82%92%e5%88%a9%e7%94%a8%e3%81%97%e3%81%9f%e5%a4%89%e6%8f%9b%e3%82%92%e3%81%97%e3%81%9f%e3%81%84 aria-label=他の入力情報を利用した変換をしたい>他の入力情報を利用した変換をしたい</a></li><li><a href=#%e8%a4%87%e6%95%b0%e7%a8%ae%e9%a1%9e%e3%81%ae%e5%85%a5%e5%8a%9b%e3%83%87%e3%83%bc%e3%82%bf%e3%82%92%e7%b5%84%e3%81%bf%e5%90%88%e3%82%8f%e3%81%9b%e3%81%9f%e5%87%a6%e7%90%86%e3%82%92%e3%81%97%e3%81%9f%e3%81%84--%e8%bf%94%e3%82%8a%e5%80%a4%e3%82%92%e8%bf%bd%e5%8a%a0%e3%81%97%e3%81%9f%e3%81%84 aria-label="複数種類の入力データを組み合わせた処理をしたい && 返り値を追加したい">複数種類の入力データを組み合わせた処理をしたい && 返り値を追加したい</a></li></ul></li></ul></li><li><a href=#%e3%83%99%e3%83%bc%e3%82%b9%e3%82%af%e3%83%a9%e3%82%b9%e3%81%ae%e3%83%aa%e3%83%95%e3%82%a1%e3%83%ac%e3%83%b3%e3%82%b9 aria-label=ベースクラスのリファレンス>ベースクラスのリファレンス</a></li></ul></div></details></div><div class=post-content><div class=links-grid><div class=link-item><a href=https://albumentations.ai/ target=_blank><i class="fas fa-project-diagram"></i><p>Project</p></a></div><div class=link-item><a href=https://arxiv.org/abs/1809.06839 target=_blank><i class="fa-solid fa-file-pdf"></i><p>Paper</p></a></div><div class=link-item><a href=https://github.com/albumentations-team/albumentations target=_blank><i class="fab fa-github"></i><p>Code</p></a></div><div class=link-item><a href=https://github.com/frkake/albumentations_post target=_blank><i class="fas fa-external-link-alt"></i><p>Other</p></a></div></div><hr><p>なんだかものすごく久しぶりの投稿ですが、今回はAlbumentationsにおける自作変換クラス作成について書いていきます。</p><p>画像変換するとき、Albumentationsって便利ですよね。なんといっても変換できる種類の数が豊富なのが嬉しいです。<br>ただ、自分で新たに変換クラスを作成しようとすると、ドキュメントが豊富とは言えないと思うので、誰かの役に立てばと思い、今回の記事を書くことにしました（未来の自分のためかもしれない）。</p><p>実行例はすべて<a href=https://github.com/frkake/albumentations_post>このリポジトリ</a>にあります。</p><h2 id=基本的な使い方>基本的な使い方<a hidden class=anchor aria-hidden=true href=#基本的な使い方>#</a></h2><h3 id=マスク画像を使って画像をクロップする>マスク画像を使って画像をクロップする<a hidden class=anchor aria-hidden=true href=#マスク画像を使って画像をクロップする>#</a></h3><p>Albumentationsの基本的な使い方を確認するために、以下のコードを実行してみます。画像とマスクの大きさが中途半端で申し訳ないです。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>) <span style=color:#75715e># image.shape: (340, 500, 3)</span>
</span></span><span style=display:flex><span>mask <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE) <span style=color:#75715e># mask.shape: (340, 500)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>CropNonEmptyMaskIfExists(height<span style=color:#f92672>=</span><span style=color:#ae81ff>200</span>, width<span style=color:#f92672>=</span><span style=color:#ae81ff>200</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>PadIfNeeded(min_height<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>, min_width<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>, border_mode<span style=color:#f92672>=</span>cv2<span style=color:#f92672>.</span>BORDER_CONSTANT, 
</span></span><span style=display:flex><span>                  value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>), mask_value<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, mask<span style=color:#f92672>=</span>mask_dog)
</span></span><span style=display:flex><span>grid_image <span style=color:#f92672>=</span> make_grid_image(transformed<span style=color:#f92672>.</span>values(), n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>2</span>) <span style=color:#75715e># 結果の画像をタイル状に並べる</span>
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/crop_dog_by_mask.png&#39;</span>, grid_image)
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
make_grid_image()<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p><code>make_grid_image</code>関数は、複数の画像をタイル状に並べる関数です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>make_grid_image</span>(
</span></span><span style=display:flex><span>    images: Sequence[np<span style=color:#f92672>.</span>ndarray],
</span></span><span style=display:flex><span>    n_cols: int,
</span></span><span style=display:flex><span>):
</span></span><span style=display:flex><span>    images <span style=color:#f92672>=</span> [  cv2<span style=color:#f92672>.</span>cvtColor(image, cv2<span style=color:#f92672>.</span>COLOR_GRAY2RGB)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> image<span style=color:#f92672>.</span>ndim <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span> <span style=color:#66d9ef>else</span> image <span style=color:#66d9ef>for</span> image <span style=color:#f92672>in</span> images]
</span></span><span style=display:flex><span>    n_rows <span style=color:#f92672>=</span> len(images) <span style=color:#f92672>//</span> n_cols
</span></span><span style=display:flex><span>    h, w, c <span style=color:#f92672>=</span> images[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>    grid_image <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((h <span style=color:#f92672>*</span> n_rows, w <span style=color:#f92672>*</span> n_cols, c), dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i, image <span style=color:#f92672>in</span> enumerate(images):
</span></span><span style=display:flex><span>        row <span style=color:#f92672>=</span> i <span style=color:#f92672>//</span> n_cols
</span></span><span style=display:flex><span>        col <span style=color:#f92672>=</span> i <span style=color:#f92672>%</span> n_cols
</span></span><span style=display:flex><span>        grid_image[row <span style=color:#f92672>*</span> h:(row <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> h, col <span style=color:#f92672>*</span> w:(col <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> w] <span style=color:#f92672>=</span> image
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> grid_image
</span></span></code></pre></div></div><div class=tile-images style=grid-template-columns:repeat(3,1fr)><figure class=centered-figure><a href=data/images/dog_and_cat.png class=magnific-image><img src=data/images/dog_and_cat.png alt=images/dog_and_cat.png></a><figcaption>images/dog_and_cat.png</figcaption></figure><figure class=centered-figure><a href=data/masks/dog.png class=magnific-image><img src=data/masks/dog.png alt=masks/dog.png></a><figcaption>masks/dog.png</figcaption></figure><figure class=centered-figure><a href=data/results/crop_dog_by_mask.png class=magnific-image><img src=data/results/crop_dog_by_mask.png alt=data/results/crop_dog_by_mask.png></a><figcaption>data/results/crop_dog_by_mask.png</figcaption></figure></div><p>ここでは、画像(=image)に犬と猫が写った写真。マスク(=mask)には犬の領域に対応したマスク画像を与えています。
データ変換のパイプラインとしては次の処理を行っています。</p><ol><li><code>A.CropNonEmptyMaskIfExists</code>でマスクを含むような形で画像を200x200にクロップ</li><li><code>A.Resize</code>で256x256にリサイズ</li><li><code>A.PadIfNeeded</code>で外周4ピクセル分をを128でパディング</li></ol><p>ご覧の通り、犬の領域に合わせて画像がクロップされていることがわかります。<br>imageとmaskが同様に変換されていることが確認できます。<br>解像度の関係でわかりにくいかもしれませんが、imageとmaskによってResizeによる補間処理は異なっています。imageの方は、引数通り線形補間が行われますが、maskの方は最近傍補間が行われています。</p><p><code>A.Compose</code>に一連の変換処理をリストで渡すことで、変換処理をパイプラインとして実行できます。<br>基本的にAlbumentationsの変換処理のフォーマットはNumpy形式と決まっており、<code>A.Compose</code>は、まず初めに入力がそれらの形式になっているのかのチェックやimageとmaskが同じshapeなのかなどのチェックを行います。その後、変換処理を実行していきます。</p><p>今回の記事ではRGB画像とマスク画像しか扱いませんが、他にもBBoxやキーポイントなどもいい感じに変換できます。</p><h3 id=マスクが複数になったら>マスクが複数になったら<a hidden class=anchor aria-hidden=true href=#マスクが複数になったら>#</a></h3><p>マスクが複数になったら、maskの代わりに各マスクをリストにしたmasksを引数として渡してあげると複数のマスクに同様の変換を適用してくれます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>) <span style=color:#75715e># image.shape: (340, 500, 3)</span>
</span></span><span style=display:flex><span>mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE) <span style=color:#75715e># mask_dog.shape: (340, 500)</span>
</span></span><span style=display:flex><span>mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE) <span style=color:#75715e># mask_cat.shape: (340, 500)</span>
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, masks<span style=color:#f92672>=</span>[mask_dog, mask_cat])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>grid_image <span style=color:#f92672>=</span> make_grid_image([transformed[<span style=color:#e6db74>&#34;image&#34;</span>], ] <span style=color:#f92672>+</span> transformed[<span style=color:#e6db74>&#39;masks&#39;</span>], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/crop_dog_and_cat_by_masks.png&#39;</span>, grid_image)
</span></span></code></pre></div><div class=tile-images style=grid-template-columns:repeat(2,1fr)><figure class=centered-figure><a href=data/images/dog_and_cat.png class=magnific-image><img src=data/images/dog_and_cat.png alt=images/dog_and_cat.png></a><figcaption>images/dog_and_cat.png</figcaption></figure><figure class=centered-figure><a href=data/masks/dog.png class=magnific-image><img src=data/masks/dog.png alt=masks/dog.png></a><figcaption>masks/dog.png</figcaption></figure><figure class=centered-figure><a href=data/masks/cat.png class=magnific-image><img src=data/masks/cat.png alt=masks/cat.png></a><figcaption>masks/cat.png</figcaption></figure><figure class=centered-figure><a href=data/results/crop_dog_and_cat_by_masks.png class=magnific-image><img src=data/results/crop_dog_and_cat_by_masks.png alt=data/results/crop_dog_and_cat_by_masks.png></a><figcaption>data/results/crop_dog_and_cat_by_masks.png</figcaption></figure></div><p><code>A.CropNonEmptyMaskIfExists</code>は、複数のマスクがあると、それらのマスク領域の和集合を含むようにしてクロップします。この場合、犬か猫の領域のどちらかを少なくとも含むように、領域をクロップします。</p><p>Albumentationsの各変換モジュールがどのターゲット（mask, bbox, keypoint, global_label）に対して作用するのかは、<a href=https://albumentations.ai/docs/api_reference/full_reference/>リファレンス</a>を見るとわかりやすいです。<br>Pixel-levelの変換は、輝度調整や色調変換、ボケやノイズなどの効果をつけたりするものが多く、画像にのみ作用します。<br>Spatial-levelの変換は、クロップやリサイズ、パディングや回転などの幾何変換を伴うものが多く、画像以外にもマスクやBBox、キーポイントなどにも作用します。各クラスによって作用するターゲットが異なるので、リファレンスの表を見て確認する必要があります。</p><h2 id=自作クラスの作成>自作クラスの作成<a hidden class=anchor aria-hidden=true href=#自作クラスの作成>#</a></h2><p>さて、ここからが本題です。自作の変換クラスを作成してみます。まずは基本的な自作クラスの作成方法を解説します。</p><h3 id=基本編>基本編<a hidden class=anchor aria-hidden=true href=#基本編>#</a></h3><p>Albumentationsでは、主に次の3つのクラスをベースクラスとして自作クラスを作成します。</p><ol><li><code>A.BasicTransform</code><br><code>A.ImageOnlyTransform</code>と<code>A.DualTransform</code>の基底クラス。<br>色々な変換をするときのパラメータを設定するメソッドを持っています。</li><li><code>A.ImageOnlyTransform</code><br>画像のみを変換するときに使う基底クラス。</li><li><code>A.DualTransform</code><br>画像とマスクやBBox、キーポイントを同時に変換するときに使う基底クラス</li></ol><p>特殊な変換クラスでもない限り、基本的には<code>A.ImageOnlyTransform</code>か<code>A.DualTransform</code>を継承して作成していくのが一般的だと思います。</p><h4 id=imageonlytransformを継承したクラス>ImageOnlyTransformを継承したクラス<a hidden class=anchor aria-hidden=true href=#imageonlytransformを継承したクラス>#</a></h4><p><code>A.ImageOnlyTransform</code>を継承して、画像の特定のチャネルだけ残して他を0にする自作変換クラス<code>SelectChannel</code>を作成してみます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SelectChannel</span>(A<span style=color:#f92672>.</span>ImageOnlyTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, channel: int, always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        super(SelectChannel, self)<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>channel <span style=color:#f92672>=</span> channel
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(self, image: np<span style=color:#f92672>.</span>ndarray, <span style=color:#f92672>**</span>params) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        H, W, C <span style=color:#f92672>=</span> image<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>        canvas <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros_like(image)
</span></span><span style=display:flex><span>        canvas[<span style=color:#f92672>...</span>, self<span style=color:#f92672>.</span>channel] <span style=color:#f92672>=</span> image[<span style=color:#f92672>...</span>, self<span style=color:#f92672>.</span>channel]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> canvas
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_transform_init_args_names</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;channel&#34;</span>,)
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p>青だけ残す処理を行ってみます。OpenCVで読み込んでおり、BGRなので0チャネル目が青です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    SelectChannel(channel<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image)
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/select_b.png&#39;</span>, transformed[<span style=color:#e6db74>&#34;image&#34;</span>])
</span></span></code></pre></div><div class=tile-images style=grid-template-columns:repeat(2,1fr)><figure class=centered-figure><a href=data/images/dog_and_cat.png class=magnific-image><img src=data/images/dog_and_cat.png alt=images/dog_and_cat.png></a><figcaption>images/dog_and_cat.png</figcaption></figure><figure class=centered-figure><a href=data/results/select_b.png class=magnific-image><img src=data/results/select_b.png alt=results/select_b.png></a><figcaption>results/select_b.png</figcaption></figure></div></div><p>このように画像への処理内容は<code>apply()</code>に記述します。<br><code>get_transform_init_args_names()</code>というメソッドは、<code>A.ReplayCompose</code>を使うときに必要になるメソッドです。まだ必要ないのですが、後で<code>A.ReplayCompose</code>の説明もしたいので、まとめて定義しておきます。<br><code>apply()</code>には、<code>transform(image=image)</code>で渡されたimageが渡されます。それに対して処理を行って返却すると、返り値の辞書の<code>image</code>キーに値が格納されます。</p><h4 id=dualtransformを継承したクラス>DualTransformを継承したクラス<a hidden class=anchor aria-hidden=true href=#dualtransformを継承したクラス>#</a></h4><p>さて、次は指定した領域をクロップするクラス <code>Crop</code>を作成してみます。<code>A.Crop</code>の簡略版です。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Crop</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        x_min: int, 
</span></span><span style=display:flex><span>        y_min: int, 
</span></span><span style=display:flex><span>        x_max: int, 
</span></span><span style=display:flex><span>        y_max: int, 
</span></span><span style=display:flex><span>        always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, 
</span></span><span style=display:flex><span>        p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    ):
</span></span><span style=display:flex><span>        super(Crop, self)<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>x_min <span style=color:#f92672>=</span> x_min
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>y_min <span style=color:#f92672>=</span> y_min
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>x_max <span style=color:#f92672>=</span> x_max
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>y_max <span style=color:#f92672>=</span> y_max
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(self, image, <span style=color:#f92672>**</span>params):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> image[self<span style=color:#f92672>.</span>y_min:self<span style=color:#f92672>.</span>y_max, self<span style=color:#f92672>.</span>x_min:self<span style=color:#f92672>.</span>x_max]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_to_mask</span>(self, mask: np<span style=color:#f92672>.</span>ndarray, <span style=color:#f92672>**</span>params) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mask[self<span style=color:#f92672>.</span>y_min:self<span style=color:#f92672>.</span>y_max, self<span style=color:#f92672>.</span>x_min:self<span style=color:#f92672>.</span>x_max]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_to_masks</span>(self, masks: List[np<span style=color:#f92672>.</span>ndarray], <span style=color:#f92672>**</span>params) <span style=color:#f92672>-&gt;</span> List[np<span style=color:#f92672>.</span>ndarray]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [mask[self<span style=color:#f92672>.</span>y_min:self<span style=color:#f92672>.</span>y_max, self<span style=color:#f92672>.</span>x_min:self<span style=color:#f92672>.</span>x_max] <span style=color:#66d9ef>for</span> mask <span style=color:#f92672>in</span> masks]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_transform_init_args_names</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;x_min&#34;</span>, <span style=color:#e6db74>&#34;y_min&#34;</span>, <span style=color:#e6db74>&#34;x_max&#34;</span>, <span style=color:#e6db74>&#34;y_max&#34;</span>)
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    Crop(x_min<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>, y_min<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span>, x_max<span style=color:#f92672>=</span><span style=color:#ae81ff>300</span>, y_max<span style=color:#f92672>=</span><span style=color:#ae81ff>300</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>PadIfNeeded(min_height<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>, min_width<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>, border_mode<span style=color:#f92672>=</span>cv2<span style=color:#f92672>.</span>BORDER_CONSTANT, 
</span></span><span style=display:flex><span>                  value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>), mask_value<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, masks<span style=color:#f92672>=</span>[mask_dog, mask_cat])
</span></span><span style=display:flex><span>grid_image <span style=color:#f92672>=</span> make_grid_image([transformed[<span style=color:#e6db74>&#34;image&#34;</span>],] <span style=color:#f92672>+</span> transformed[<span style=color:#e6db74>&#39;masks&#39;</span>], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/crop_constant.png&#39;</span>, grid_image)
</span></span></code></pre></div><div class=tile-images style=grid-template-columns:repeat(2,1fr)><figure class=centered-figure><a href=data/images/dog_and_cat.png class=magnific-image><img src=data/images/dog_and_cat.png alt=images/dog_and_cat.png></a><figcaption>images/dog_and_cat.png</figcaption></figure><figure class=centered-figure><a href=data/results/crop_constant.png class=magnific-image><img src=data/results/crop_constant.png alt=results/crop_constant.png></a><figcaption>results/crop_constant.png</figcaption></figure></div><p><code>Crop</code>クラスで指定した領域がクロップされていることが確認できます。</p></div><p>このクラスは、画像とマスクを同時にクロップする処理を行います。<code>apply()</code>メソッドは画像に対する処理、<code>apply_to_mask()</code>メソッドはマスクに対する処理、<code>apply_to_masks()</code>メソッドは複数のマスクに対する処理を行います。</p><p><code>A.DualTransform</code>では、他にも <code>apply_to_bbox()</code>、<code>apply_to_keypoint()</code>、<code>apply_to_global_label()</code> などがあり、それぞれのターゲットに対してメソッドを定義することができます。</p><div class="notice note"><div class=notice-header><div class=notice-icon><i class="fas fa-sticky-note"></i></div><div class=notice-title>Note</div></div><div class=notice-content><p>実は、上の変換クラス<code>Crop</code>はさらに単純化することができます。<code>apply_to_mask()</code>と<code>apply_to_masks</code>を定義していますが、次のように<code>apply()</code>メソッドを定義するだけで、maskも同様にクロップされます。imageとmaskは対応したものとして扱われ、同じ変換処理が適用されます。<br>そのため、次の<code>Crop</code>クラスは上の<code>Crop</code>クラスと同じ挙動をします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Crop</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, x_min, y_min, x_max, y_max, always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        super(Crop, self)<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>x_min <span style=color:#f92672>=</span> x_min
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>y_min <span style=color:#f92672>=</span> y_min
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>x_max <span style=color:#f92672>=</span> x_max
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>y_max <span style=color:#f92672>=</span> y_max
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(self, image, <span style=color:#f92672>**</span>params):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> image[self<span style=color:#f92672>.</span>y_min:self<span style=color:#f92672>.</span>y_max, self<span style=color:#f92672>.</span>x_min:self<span style=color:#f92672>.</span>x_max]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_transform_init_args_names</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;x_min&#34;</span>, <span style=color:#e6db74>&#34;y_min&#34;</span>, <span style=color:#e6db74>&#34;x_max&#34;</span>, <span style=color:#e6db74>&#34;y_max&#34;</span>)
</span></span></code></pre></div><p>唯一違うのはリサイズなどで補間処理を見つけたら、mask（およびmasks）の場合は最近傍補間が適用されるように自動的に修正されるという点です。<br>imageとは異なる処理をしたい場合や可読性を上げたい場合を除けば、<code>apply()</code> メソッドのみを定義しておけば十分です。</p></div></div><h3 id=応用編>応用編<a hidden class=anchor aria-hidden=true href=#応用編>#</a></h3><p>応用編では、より複雑な変換クラスを作成してみます。</p><h4 id=ランダム値を扱いたい>ランダム値を扱いたい<a hidden class=anchor aria-hidden=true href=#ランダム値を扱いたい>#</a></h4><h5 id=適用するごとにランダム値を生成する>適用するごとにランダム値を生成する<a hidden class=anchor aria-hidden=true href=#適用するごとにランダム値を生成する>#</a></h5><p>まずは、ランダムなシフトを行う変換クラス<code>RandomShift</code>を作成してみます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RandomShift</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        x_shift: Tuple[int, int],
</span></span><span style=display:flex><span>        y_shift: Tuple[int, int],
</span></span><span style=display:flex><span>        always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, 
</span></span><span style=display:flex><span>        p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    ):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>x_shift <span style=color:#f92672>=</span> x_shift
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>y_shift <span style=color:#f92672>=</span> y_shift
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        image: np<span style=color:#f92672>.</span>ndarray, 
</span></span><span style=display:flex><span>        x_shift: int, 
</span></span><span style=display:flex><span>        y_shift: int, 
</span></span><span style=display:flex><span>        <span style=color:#f92672>**</span>params: Any,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        H, W, <span style=color:#f92672>*</span>_ <span style=color:#f92672>=</span> image<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>        canvas <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros_like(image)
</span></span><span style=display:flex><span>        x_min <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0</span>, x_shift)
</span></span><span style=display:flex><span>        y_min <span style=color:#f92672>=</span> max(<span style=color:#ae81ff>0</span>, y_shift)
</span></span><span style=display:flex><span>        x_max <span style=color:#f92672>=</span> min(W, W <span style=color:#f92672>+</span> x_shift)
</span></span><span style=display:flex><span>        y_max <span style=color:#f92672>=</span> min(H, H <span style=color:#f92672>+</span> y_shift)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        canvas[y_min:y_max, x_min:x_max] <span style=color:#f92672>=</span> image[max(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span>y_shift):min(H, H <span style=color:#f92672>-</span> y_shift), 
</span></span><span style=display:flex><span>                                                 max(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span>x_shift):min(W, W <span style=color:#f92672>-</span> x_shift)]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> canvas
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_transform_init_args_names</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;x_shift&#34;</span>, <span style=color:#e6db74>&#34;y_shift&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_params</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_shift&#34;</span>: np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#f92672>*</span>self<span style=color:#f92672>.</span>x_shift),
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_shift&#34;</span>: np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#f92672>*</span>self<span style=color:#f92672>.</span>y_shift),
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p>上下左右に[-100, 100]ピクセルの範囲でランダムにシフトする処理を行ってみます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> RandomShift(x_shift<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>), y_shift<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>), p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>    mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>    mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>    transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, masks<span style=color:#f92672>=</span>[mask_dog, mask_cat])
</span></span><span style=display:flex><span>    grid_image <span style=color:#f92672>=</span> make_grid_image([transformed[<span style=color:#e6db74>&#34;image&#34;</span>],] <span style=color:#f92672>+</span> transformed[<span style=color:#e6db74>&#39;masks&#39;</span>], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;data/results/shift_</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>:</span><span style=color:#e6db74>02d</span><span style=color:#e6db74>}</span><span style=color:#e6db74>.png&#39;</span>, grid_image)
</span></span></code></pre></div><div class=tile-images style=grid-template-columns:repeat(1,1fr)><figure class=centered-figure><a href=data/results/shift_00.png class=magnific-image><img src=data/results/shift_00.png alt=data/results/shift_00.png></a><figcaption>data/results/shift_00.png</figcaption></figure><figure class=centered-figure><a href=data/results/shift_01.png class=magnific-image><img src=data/results/shift_01.png alt=data/results/shift_01.png></a><figcaption>data/results/shift_01.png</figcaption></figure></div><p>ランダムになっていることを確認するために2回実行してみました。2回とも異なるシフトが適用されていることがわかります。さらに、画像とマスクの両方で同じシフトが適用されていることも確認できます。</p></div><p><code>get_params()</code>で、適用するごとにランダムな値を生成しています。<br><code>get_params()</code>の返り値は、<code>apply()</code>メソッドの引数に渡されます。今回は<code>apply()</code>の引数に<code>x_shift</code>と<code>y_shift</code>を追加して直接受けてみましたが、特に指定しないと<code>**params</code>で受け取ることができます。<br>コラムでも述べたように、<code>apply()</code>メソッドは他のターゲットにも適用されるので、<code>apply_to_mask()</code>や<code>apply_to_bbox()</code>などでも共有して使うことができます。これにより、画像とマスクが同じシフトを受けることが保証されます。</p><h5 id=入力データに依存したランダム値を生成する>入力データに依存したランダム値を生成する<a hidden class=anchor aria-hidden=true href=#入力データに依存したランダム値を生成する>#</a></h5><p>次に、ランダムにクロップする変換クラス<code>RandomCrop</code>を作成してみます。<code>RandomCrop</code>は、ランダムにクロップする位置を変更しますが、クロップする矩形が画像の範囲を超えないようにするため、画像のサイズに依存したランダム値を生成する必要があります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RandomCrop</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        height: int,
</span></span><span style=display:flex><span>        width: int,
</span></span><span style=display:flex><span>        always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, 
</span></span><span style=display:flex><span>        p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    ):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>height <span style=color:#f92672>=</span> height
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>width <span style=color:#f92672>=</span> width
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        image: np<span style=color:#f92672>.</span>ndarray,
</span></span><span style=display:flex><span>        x_min: int,
</span></span><span style=display:flex><span>        y_min: int,
</span></span><span style=display:flex><span>        x_max: int,
</span></span><span style=display:flex><span>        y_max: int,
</span></span><span style=display:flex><span>        <span style=color:#f92672>**</span>params,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> image[y_min:y_max, x_min:x_max]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_transform_init_args_names</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;height&#34;</span>, <span style=color:#e6db74>&#34;width&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_params_dependent_on_targets</span>(self, params):
</span></span><span style=display:flex><span>        image <span style=color:#f92672>=</span> params[<span style=color:#e6db74>&#34;image&#34;</span>]
</span></span><span style=display:flex><span>        H, W, C <span style=color:#f92672>=</span> image<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>        x_min <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, W <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>width)
</span></span><span style=display:flex><span>        y_min <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, H <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>height)
</span></span><span style=display:flex><span>        x_max <span style=color:#f92672>=</span> x_min <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>width
</span></span><span style=display:flex><span>        y_max <span style=color:#f92672>=</span> y_min <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>height
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_min&#34;</span>: x_min,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_min&#34;</span>: y_min,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_max&#34;</span>: x_max,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_max&#34;</span>: y_max,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>targets_as_params</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#34;image&#34;</span>]
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p>画像から200x200サイズの領域をランダムにクロップしてみます。今回もランダムになっているか確認するために2回実行してみます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    RandomCrop(height<span style=color:#f92672>=</span><span style=color:#ae81ff>200</span>, width<span style=color:#f92672>=</span><span style=color:#ae81ff>200</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>PadIfNeeded(min_height<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>, min_width<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>, border_mode<span style=color:#f92672>=</span>cv2<span style=color:#f92672>.</span>BORDER_CONSTANT, 
</span></span><span style=display:flex><span>                value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>), mask_value<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>    image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>    mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>    mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>    transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, masks<span style=color:#f92672>=</span>[mask_dog, mask_cat])
</span></span><span style=display:flex><span>    grid_image <span style=color:#f92672>=</span> make_grid_image([transformed[<span style=color:#e6db74>&#34;image&#34;</span>],] <span style=color:#f92672>+</span> transformed[<span style=color:#e6db74>&#39;masks&#39;</span>], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>    cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;data/results/randomcrop_</span><span style=color:#e6db74>{</span>i<span style=color:#e6db74>:</span><span style=color:#e6db74>02d</span><span style=color:#e6db74>}</span><span style=color:#e6db74>.png&#39;</span>, grid_image)
</span></span></code></pre></div><div class=tile-images style=grid-template-columns:repeat(2,1fr)><figure class=centered-figure><a href=data/results/randomcrop_00.png class=magnific-image><img src=data/results/randomcrop_00.png alt=data/results/randomcrop_00.png></a><figcaption>data/results/randomcrop_00.png</figcaption></figure><figure class=centered-figure><a href=data/results/randomcrop_01.png class=magnific-image><img src=data/results/randomcrop_01.png alt=data/results/randomcrop_01.png></a><figcaption>data/results/randomcrop_01.png</figcaption></figure></div><p>画像内のランダムな位置がクロップされていることが確認できます。クロップ領域が画像の範囲を超えないようになっていることも確認できます。</p></div><p><code>get_params_dependent_on_targets()</code>で、<code>params</code>に含まれる<code>image</code>からランダムな値を生成しています。<code>get_params_dependent_on_targets()</code>で利用したいターゲットは、<code>targets_as_params</code>プロパティで指定しておかなければなりません。<code>target_as_params</code>で<code>params</code>のパラメータを収集（辞書を構築）して、<code>get_params_dependent_on_targets()</code>を実行する流れになっています。
<code>get_params()</code>と<code>get_params_dependent_on_targets()</code>を別々に紹介しましたが、<code>get_params_dependent_on_targets()</code>は<code>get_params()</code>の代わりに使うこともできます。両方定義した場合は、互いの返り値の辞書がマージされます。</p><h4 id=他のデータ形式も変換したい>他のデータ形式も変換したい<a hidden class=anchor aria-hidden=true href=#他のデータ形式も変換したい>#</a></h4><p>Albumentationsの標準では、画像とマスク、BBox、キーポイント、グローバルラベルへの処理をサポートしています。<br>しかし、中には文字列やリストなどの他のデータ形式を変換したい場合もあるでしょう。ここでは、入力画像ファイル名の末尾（suffix）に変換した処理名を追加する処理を加えてみましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CropAndAddSuffix</span>(Crop):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_to_str</span>(self, string: str, <span style=color:#f92672>**</span>params) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> string <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;/cropped&#34;</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>targets</span>(self) <span style=color:#f92672>-&gt;</span> List[str]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;image&#34;</span>: self<span style=color:#f92672>.</span>apply,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;mask&#34;</span>: self<span style=color:#f92672>.</span>apply,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;image_name&#34;</span>: self<span style=color:#f92672>.</span>apply_to_str,
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p><code>CropAndAddSuffix</code>を実行しています。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> CropAndAddSuffix(<span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>300</span>, <span style=color:#ae81ff>300</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>image_path <span style=color:#f92672>=</span> Path(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(str(image_path))
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, image_name<span style=color:#f92672>=</span>image_path<span style=color:#f92672>.</span>stem)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;transformed.keys(): </span><span style=color:#e6db74>{</span>transformed<span style=color:#f92672>.</span>keys()<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># ==&gt; transformed.keys(): dict_keys([&#39;image&#39;, &#39;masks&#39;, &#39;image_name&#39;])</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;transformed[&#39;image_name&#39;]: </span><span style=color:#e6db74>{</span>transformed[<span style=color:#e6db74>&#39;image_name&#39;</span>]<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># ==&gt; transformed[&#39;image_name&#39;]: dog_and_cat/cropped</span>
</span></span></code></pre></div><p>実行結果を見てみると、<code>image_name</code>キーに渡したファイル名が<code>dog_and_cat/cropped</code>に変換されていることがわかります。</p></div><p>前節で作成した<code>Crop</code>クラスに<code>apply_to_str()</code>と<code>targets</code>プロパティを追加しています。このように <code>targets</code>プロパティで渡したキーに対して、処理させたいメソッドを指定することで、他のデータ形式にも変換処理を適用できます。<br>こうすると、変換時に<code>image_name</code>というキーで渡した文字列に対して、<code>apply_to_str()</code>が適用され、<code>/cropped</code>というsuffixを追加します。<br>あまりやらないですが、どういう処理をした画像なのかをファイル名に残しておきたい場合などに使えるかもしれません。</p><h4 id=他の入力情報を利用した変換をしたい>他の入力情報を利用した変換をしたい<a hidden class=anchor aria-hidden=true href=#他の入力情報を利用した変換をしたい>#</a></h4><p><a href=#%E3%83%9E%E3%82%B9%E3%82%AF%E3%81%8C%E8%A4%87%E6%95%B0%E3%81%AB%E3%81%AA%E3%81%A3%E3%81%9F%E3%82%89>マスクが複数になったら</a>で紹介したように、複数のマスクがある場合には次のように<code>masks</code>にマスクのリストを渡すことで、それぞれのマスクに同じ変換を適用できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, masks<span style=color:#f92672>=</span>[mask_dog, mask_cat])
</span></span></code></pre></div><p>例えば、犬と猫のマスクを両方渡して、犬の方のマスク領域だけを抽出する変換クラス<code>ExtractDogArea</code>を素朴に作成すると次のようになります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CropDogArea</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        image: np<span style=color:#f92672>.</span>ndarray,
</span></span><span style=display:flex><span>        x_min: int,
</span></span><span style=display:flex><span>        y_min: int,
</span></span><span style=display:flex><span>        x_max: int,
</span></span><span style=display:flex><span>        y_max: int,
</span></span><span style=display:flex><span>        <span style=color:#f92672>**</span>params,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> image[y_min:y_max, x_min:x_max]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_params_dependent_on_targets</span>(self, params):
</span></span><span style=display:flex><span>        mask <span style=color:#f92672>=</span> params[<span style=color:#e6db74>&#34;masks&#34;</span>][<span style=color:#ae81ff>0</span>] <span style=color:#75715e># HERE!</span>
</span></span><span style=display:flex><span>        indices <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>where(mask <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        y_min, y_max <span style=color:#f92672>=</span> indices[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>min(), indices[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>        x_min, x_max <span style=color:#f92672>=</span> indices[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>min(), indices[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_min&#34;</span>: x_min,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_min&#34;</span>: y_min,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_max&#34;</span>: x_max,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_max&#34;</span>: y_max,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>targets_as_params</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#34;masks&#34;</span>]
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    CropDogArea(p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>), 
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>PadIfNeeded(
</span></span><span style=display:flex><span>        min_height<span style=color:#f92672>=</span><span style=color:#ae81ff>200</span>,
</span></span><span style=display:flex><span>        min_width<span style=color:#f92672>=</span><span style=color:#ae81ff>130</span>,
</span></span><span style=display:flex><span>        value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>),
</span></span><span style=display:flex><span>        mask_value<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>,
</span></span><span style=display:flex><span>    )],
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, masks<span style=color:#f92672>=</span>[mask_dog, mask_cat])
</span></span><span style=display:flex><span>grid_image <span style=color:#f92672>=</span> make_grid_image([transformed[<span style=color:#e6db74>&#34;image&#34;</span>],] <span style=color:#f92672>+</span> transformed[<span style=color:#e6db74>&#39;masks&#39;</span>], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/crop_dog_area.png&#39;</span>, grid_image)
</span></span></code></pre></div><p>左から画像、犬のマスク画像、猫のマスク画像に対応しており、それぞれの犬のマスク領域に対応した領域がクロップされていることがわかります。</p><p><figure class=centered-figure><a href=data/results/crop_dog_area.png class=magnific-image><img src=data/results/crop_dog_area.png alt=data/results/crop_dog_area.png></a><figcaption>data/results/crop_dog_area.png</figcaption></figure></p></div><p>しかし、これでは入力したマスクの順序を覚えておかなければならないという問題があります。様々な変換を組み合わせて適用する場合に、それらすべてのクラスで0番目のマスクが犬のマスクであることを共通化するのは難しいですし、利用する際に順序を間違えてしまう可能性もあります。<code>get_params_dependent_on_targets()</code>の中が見苦しいことになっています。</p><p>ですので、<code>mask_dog</code>と<code>mask_cat</code>を<code>masks</code>にまとめて渡すのではなく、<code>mask_dog</code>と<code>mask_cat</code>をそれぞれ<code>dog_mask</code>と<code>cat_mask</code>として渡せるようにしてみましょう。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CropDogArea</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        image: np<span style=color:#f92672>.</span>ndarray,
</span></span><span style=display:flex><span>        x_min: int,
</span></span><span style=display:flex><span>        y_min: int,
</span></span><span style=display:flex><span>        x_max: int,
</span></span><span style=display:flex><span>        y_max: int,
</span></span><span style=display:flex><span>        <span style=color:#f92672>**</span>params,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> image[y_min:y_max, x_min:x_max]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_params_dependent_on_targets</span>(self, params):
</span></span><span style=display:flex><span>        mask <span style=color:#f92672>=</span> params[<span style=color:#e6db74>&#34;mask_dog&#34;</span>]
</span></span><span style=display:flex><span>        indices <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>where(mask <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        y_min, y_max <span style=color:#f92672>=</span> indices[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>min(), indices[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>        x_min, x_max <span style=color:#f92672>=</span> indices[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>min(), indices[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>.</span>max()
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_min&#34;</span>: x_min,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_min&#34;</span>: y_min,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;x_max&#34;</span>: x_max,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;y_max&#34;</span>: y_max,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>targets_as_params</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#e6db74>&#34;mask_dog&#34;</span>]
</span></span></code></pre></div><p><code>get_params_dependent_on_targets()</code>や<code>targets_as_params</code>が<code>mask_dog</code>をそのまま利用できるようになりました。<br>しかし、なにも考えずに利用すると、<code>mask_dog</code>と<code>mask_cat</code>はマスクとして扱われないため、クロップされません。なので、実行時に「<code>mask_dog</code>と<code>mask_cat</code>はマスク処理をする対象のデータである」ことを明示的に指定する必要があります。</p><p><code>A.Compose</code>の<code>additional_targets</code>引数を使って、キーにターゲット名、値にターゲットの種類を指定します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    CropDogArea(p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>), 
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>PadIfNeeded(
</span></span><span style=display:flex><span>        min_height<span style=color:#f92672>=</span><span style=color:#ae81ff>210</span>,
</span></span><span style=display:flex><span>        min_width<span style=color:#f92672>=</span><span style=color:#ae81ff>140</span>,
</span></span><span style=display:flex><span>        value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>, <span style=color:#ae81ff>128</span>),
</span></span><span style=display:flex><span>        mask_value<span style=color:#f92672>=</span><span style=color:#ae81ff>128</span>,
</span></span><span style=display:flex><span>    )], 
</span></span><span style=display:flex><span>    additional_targets<span style=color:#f92672>=</span>{<span style=color:#e6db74>&#34;mask_dog&#34;</span>: <span style=color:#e6db74>&#34;mask&#34;</span>, <span style=color:#e6db74>&#34;mask_cat&#34;</span>: <span style=color:#e6db74>&#34;mask&#34;</span>}
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p><code>mask_dog</code>, <code>mask_cat</code>をそれぞれ処理した結果は同じキーに格納されて返ってきます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(image<span style=color:#f92672>=</span>image, mask_dog<span style=color:#f92672>=</span>mask_dog, mask_cat<span style=color:#f92672>=</span>mask_cat)
</span></span><span style=display:flex><span>grid_image <span style=color:#f92672>=</span> make_grid_image([
</span></span><span style=display:flex><span>    transformed[<span style=color:#e6db74>&#34;image&#34;</span>], 
</span></span><span style=display:flex><span>    transformed[<span style=color:#e6db74>&#34;mask_dog&#34;</span>], 
</span></span><span style=display:flex><span>    transformed[<span style=color:#e6db74>&#34;mask_cat&#34;</span>]], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/crop_dog_area.png&#39;</span>, grid_image)
</span></span></code></pre></div><p>処理結果の画像は上の結果と同じですが再掲します。<br>左から画像、犬のマスク画像、猫のマスク画像に対応しており、それぞれの犬のマスク領域に対応した領域がクロップされていることがわかります。</p><div class=tile-images style=grid-template-columns:repeat(1,1fr)><figure class=centered-figure><a href=data/results/crop_dog_area.png class=magnific-image><img src=data/results/crop_dog_area.png alt=data/results/crop_dog_area.png></a><figcaption>data/results/crop_dog_area.png</figcaption></figure></div></div><p><code>additional_targets</code> &ndash;> <code>targets</code>のように辞書をたどって行くことで、処理対象のメソッドへとたどり着きます。<br><code>A.DualTransform</code>には次の<code>targets</code>が定義されているので、<code>"mask_dog"</code> &ndash;> <code>"mask"</code> &ndash;> <code>apply_to_mask()</code> にたどり着きます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>targets</span>(self) <span style=color:#f92672>-&gt;</span> Dict[str, Callable[<span style=color:#f92672>...</span>, Any]]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;image&#34;</span>: self<span style=color:#f92672>.</span>apply,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;mask&#34;</span>: self<span style=color:#f92672>.</span>apply_to_mask,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;masks&#34;</span>: self<span style=color:#f92672>.</span>apply_to_masks,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;bboxes&#34;</span>: self<span style=color:#f92672>.</span>apply_to_bboxes,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;keypoints&#34;</span>: self<span style=color:#f92672>.</span>apply_to_keypoints,
</span></span><span style=display:flex><span>        }
</span></span></code></pre></div><h4 id=複数種類の入力データを組み合わせた処理をしたい--返り値を追加したい>複数種類の入力データを組み合わせた処理をしたい && 返り値を追加したい<a hidden class=anchor aria-hidden=true href=#複数種類の入力データを組み合わせた処理をしたい--返り値を追加したい>#</a></h4><p>これまでの変換処理は、それぞれの画像やマスクに対して処理を行い、その結果を<code>image</code>や<code>masks</code>として返していました。しかし、処理結果に追加の情報を返したい場合や、複数種類の入力データを組み合わせた処理を行いたい場合もあるでしょう。</p><p>この節では、複数の別々に用意したカテゴリマスクを一枚の画像にまとめる処理を行う変換クラス<code>MergeMasks</code>を作成してみます。<br>具体的には、犬、猫、芝生、木の4つのマスクを別々に用意したので、それらを一枚の画像にまとめてセグメンテーション用のマスクを作成します。ただし、犬、猫はオブジェクトクラス、芝生、木は背景クラスとしてラベルをまとめます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MergeMasks</span>(A<span style=color:#f92672>.</span>DualTransform):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        object_value: Tuple[int, int, int] <span style=color:#f92672>=</span> (<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        bg_value: Tuple[int, int, int] <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>        always_apply<span style=color:#f92672>=</span><span style=color:#66d9ef>False</span>,
</span></span><span style=display:flex><span>        p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>    ):
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__init__(always_apply, p)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>object_value <span style=color:#f92672>=</span> object_value
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>bg_value <span style=color:#f92672>=</span> bg_value
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply</span>(self, img: np<span style=color:#f92672>.</span>ndarray, <span style=color:#f92672>**</span>params) <span style=color:#f92672>-&gt;</span> np<span style=color:#f92672>.</span>ndarray:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> img
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>apply_with_params</span>(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        params: Dict[str, Any], 
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>args: Any, 
</span></span><span style=display:flex><span>        <span style=color:#f92672>**</span>kwargs: Any,
</span></span><span style=display:flex><span>    ) <span style=color:#f92672>-&gt;</span> Dict[str, Any]:
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> super()<span style=color:#f92672>.</span>apply_with_params(params, <span style=color:#f92672>*</span>args, <span style=color:#f92672>**</span>kwargs)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        H, W <span style=color:#f92672>=</span> res[<span style=color:#e6db74>&#34;mask_dog&#34;</span>]<span style=color:#f92672>.</span>shape
</span></span><span style=display:flex><span>        canvas <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>zeros((H, W, <span style=color:#ae81ff>3</span>), dtype<span style=color:#f92672>=</span>np<span style=color:#f92672>.</span>uint8)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        mask_object <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>logical_or(res[<span style=color:#e6db74>&#34;mask_dog&#34;</span>], res[<span style=color:#e6db74>&#34;mask_cat&#34;</span>])
</span></span><span style=display:flex><span>        mask_bg <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>logical_or(res[<span style=color:#e6db74>&#34;mask_grass&#34;</span>], res[<span style=color:#e6db74>&#34;mask_tree&#34;</span>])
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        canvas[mask_object] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>object_value
</span></span><span style=display:flex><span>        canvas[mask_bg] <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>bg_value        
</span></span><span style=display:flex><span>        res[<span style=color:#e6db74>&#34;mask_merged&#34;</span>] <span style=color:#f92672>=</span> canvas
</span></span><span style=display:flex><span>        res[<span style=color:#e6db74>&#34;image_overlay&#34;</span>] <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>addWeighted(res[<span style=color:#e6db74>&#34;image&#34;</span>], <span style=color:#ae81ff>0.5</span>, canvas, <span style=color:#ae81ff>0.5</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_transform_init_args_names</span>(self) <span style=color:#f92672>-&gt;</span> Tuple[str]:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (<span style=color:#e6db74>&#34;object_value&#34;</span>, <span style=color:#e6db74>&#34;bg_value&#34;</span>)
</span></span></code></pre></div><script>document.addEventListener("DOMContentLoaded",function(){function e(){var e=document.querySelectorAll(".collapse");e.forEach(function(e){e.classList.contains("listener-added")||(e.classList.add("listener-added"),e.addEventListener("click",function(){this.classList.toggle("active");var e=this.nextElementSibling;e.style.display==="block"?e.style.display="none":e.style.display="block"}))})}e();var t=new MutationObserver(e);t.observe(document.body,{childList:!0,subtree:!0})})</script><button class=collapse>
実行例<svg class="arrow" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M5 7.5l5 5 5-5" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button><div class=content><p>画像と各マスクを[-10, 10]度の範囲でランダムに回転させ、<code>MergeMasks</code>でマスクをマージしてみます。</p><p>処理の対象がわかりやすいように、少しコードが長くなってしまいますが、犬、猫、芝生、木のマスクを読み込んでtransformに渡しています。<br>返り値には、マージ後のマスク<code>mask_merged</code>と、画像とマスクを重ねた画像<code>image_overlay</code>が追加されているので、それらを描画してみました。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>transform <span style=color:#f92672>=</span> A<span style=color:#f92672>.</span>Compose([
</span></span><span style=display:flex><span>    A<span style=color:#f92672>.</span>Rotate(limit<span style=color:#f92672>=</span><span style=color:#ae81ff>10</span>, border_mode<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>, p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>), 
</span></span><span style=display:flex><span>    MergeMasks(object_value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>170</span>, <span style=color:#ae81ff>246</span>), bg_value<span style=color:#f92672>=</span>(<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>0</span>), p<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>], additional_targets<span style=color:#f92672>=</span>{
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;mask_dog&#34;</span>: <span style=color:#e6db74>&#34;mask&#34;</span>, 
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;mask_cat&#34;</span>: <span style=color:#e6db74>&#34;mask&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;mask_grass&#34;</span>: <span style=color:#e6db74>&#34;mask&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;mask_tree&#34;</span>: <span style=color:#e6db74>&#34;mask&#34;</span>,
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>image <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/images/dog_and_cat.png&#39;</span>)
</span></span><span style=display:flex><span>mask_dog <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/dog.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>mask_cat <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/cat.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>mask_grass <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/grass.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>mask_tree <span style=color:#f92672>=</span> cv2<span style=color:#f92672>.</span>imread(<span style=color:#e6db74>&#39;data/masks/tree.png&#39;</span>, cv2<span style=color:#f92672>.</span>IMREAD_GRAYSCALE)
</span></span><span style=display:flex><span>transformed <span style=color:#f92672>=</span> transform(
</span></span><span style=display:flex><span>    image<span style=color:#f92672>=</span>image, 
</span></span><span style=display:flex><span>    mask_dog<span style=color:#f92672>=</span>mask_dog, 
</span></span><span style=display:flex><span>    mask_cat<span style=color:#f92672>=</span>mask_cat,
</span></span><span style=display:flex><span>    mask_grass<span style=color:#f92672>=</span>mask_grass,
</span></span><span style=display:flex><span>    mask_tree<span style=color:#f92672>=</span>mask_tree,
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>grid_image <span style=color:#f92672>=</span> make_grid_image([
</span></span><span style=display:flex><span>    transformed[<span style=color:#e6db74>&#34;image&#34;</span>], 
</span></span><span style=display:flex><span>    transformed[<span style=color:#e6db74>&#34;mask_merged&#34;</span>], 
</span></span><span style=display:flex><span>    transformed[<span style=color:#e6db74>&#34;image_overlay&#34;</span>]], n_cols<span style=color:#f92672>=</span><span style=color:#ae81ff>3</span>)
</span></span><span style=display:flex><span>cv2<span style=color:#f92672>.</span>imwrite(<span style=color:#e6db74>&#39;data/results/merged_mask.png&#39;</span>, grid_image)
</span></span></code></pre></div><p><figure class=centered-figure><a href=data/results/merged_mask.png class=magnific-image><img src=data/results/merged_mask.png alt=data/results/merged_mask.png></a><figcaption>data/results/merged_mask.png</figcaption></figure></p></div><p>複数のマスクを組み合わせたり、追加の情報を返す場合は、<code>apply_with_params()</code>メソッドを使うと実現できます。<br>本来の<code>apply_with_params()</code>は、各ターゲットに対して適用するメソッドの選択やちょっとしたパラメータの更新を行い、実際に各処理（<code>apply()</code>や<code>apply_to_mask()</code>など）を実行するメソッドです。
言い換えると、各入力情報を保持しており、<code>apply_with_params()</code>の返り値がtransformしたときの返り値となります。ですので、ここでは返り値の辞書に新たな要素を追加しています。
引数である<code>params</code>には、<code>get_params()</code>と<code>get_params_dependent_on_targets()</code>から受け取った値が入っており、<code>args</code>, <code>kwargs</code>には、各入力データが入っています。</p><h2 id=ベースクラスのリファレンス>ベースクラスのリファレンス<a hidden class=anchor aria-hidden=true href=#ベースクラスのリファレンス>#</a></h2><table><thead><tr><th>メソッド or プロパティ</th><th>説明</th></tr></thead><tbody><tr><td><code>apply()</code></td><td>画像に対する変換処理を行うメソッド。 <code>A.DualTransform</code> の場合は、マスクに対する処理も行う。</td></tr><tr><td><code>targets_as_params</code></td><td><code>get_params_dependent_on_targets()</code>で利用するターゲットを指定</td></tr><tr><td><code>add_targets()</code></td><td>辞書形式で追加で処理したいターゲット名とその対象として扱わせたいターゲット名を指定します。上の例で出していた<code>A.Compose</code>の<code>additional_targets</code>と同じです。<code>A.Compose</code>で<code>additional_targets</code>を指定すると、内部的には各変換クラスの<code>add_targets()</code>が呼ばれています。</td></tr><tr><td><code>apply_with_params()</code></td><td><code>targets</code>で指定した辞書に従って、各ターゲットに対する処理を行う。処理を行う前に<code>update_params()</code>によるパラメータ更新も行う。</td></tr><tr><td><code>get_params()</code></td><td>入力データに依存しないパラメータを準備する関数。変換ごとに一度しか呼ばれないので、同時に入力したデータでランダム値を共有したい場合に便利。</td></tr><tr><td><code>get_params_dependent_on_targets()</code></td><td>入力データに依存したパラメータを準備する関数。<code>get_params()</code>の上位互換という印象。</td></tr><tr><td><code>get_transform_init_args_names()</code></td><td>そのクラスを初期化するのに必要なパラメータ名のリストを返す。通常は不要だが、<code>A.ReplanCompose</code>などで同じパラメータを使いまわす場合に使う。</td></tr><tr><td><code>set_deterministic()</code></td><td></td></tr><tr><td><code>targets</code></td><td>変換対象のターゲット名とそれを処理するメソッドを指定する。</td></tr><tr><td><code>update_params()</code></td><td><code>apply_with_params()</code>内部で最初に呼ばれる。 <code>params</code>と<code>kwargs</code>の両方が渡されるので、<code>get_params()</code>, <code>get_params_dependent_on_targets()</code>の中で一番使える情報が多い。</td></tr></tbody></table><p>変換に利用されるパラメータ<code>params</code>は、次の3つのメソッドを順番に呼び出し、辞書を更新していきます。</p><ol><li><code>get_params()</code></li><li><code>get_params_dependent_on_targets()</code></li><li><code>update_params()</code></li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://frkake.com/tags/python/>Python</a></li><li><a href=https://frkake.com/tags/albumentations/>Albumentations</a></li><li><a href=https://frkake.com/tags/data-augmentation/>Data Augmentation</a></li></ul><nav class=paginav><a class=next href=https://frkake.com/posts/2023-11-14-3d-gaussian-splatting/><span class=title>次へ »</span><br><span>3D Gaussian Splatting</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Albumentationsにおける自作変換クラス作成 on x" href="https://x.com/intent/tweet/?text=Albumentations%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e8%87%aa%e4%bd%9c%e5%a4%89%e6%8f%9b%e3%82%af%e3%83%a9%e3%82%b9%e4%bd%9c%e6%88%90&amp;url=https%3a%2f%2ffrkake.com%2fposts%2f2024-06-14-albumentations%2f&amp;hashtags=Python%2cAlbumentations%2cDataAugmentation"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Albumentationsにおける自作変換クラス作成 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ffrkake.com%2fposts%2f2024-06-14-albumentations%2f&amp;title=Albumentations%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e8%87%aa%e4%bd%9c%e5%a4%89%e6%8f%9b%e3%82%af%e3%83%a9%e3%82%b9%e4%bd%9c%e6%88%90&amp;summary=Albumentations%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e8%87%aa%e4%bd%9c%e5%a4%89%e6%8f%9b%e3%82%af%e3%83%a9%e3%82%b9%e4%bd%9c%e6%88%90&amp;source=https%3a%2f%2ffrkake.com%2fposts%2f2024-06-14-albumentations%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Albumentationsにおける自作変換クラス作成 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ffrkake.com%2fposts%2f2024-06-14-albumentations%2f&title=Albumentations%e3%81%ab%e3%81%8a%e3%81%91%e3%82%8b%e8%87%aa%e4%bd%9c%e5%a4%89%e6%8f%9b%e3%82%af%e3%83%a9%e3%82%b9%e4%bd%9c%e6%88%90"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Albumentationsにおける自作変換クラス作成 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ffrkake.com%2fposts%2f2024-06-14-albumentations%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li></ul></footer></article></main><script src=/js/cite.js></script>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="コピー";function s(){t.innerHTML="コピーされました!",setTimeout(()=>{t.innerHTML="コピー"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script><script>$(document).ready(function(){$(".magnific-image").magnificPopup({type:"image",closeOnContentClick:!0})})</script></body></html>